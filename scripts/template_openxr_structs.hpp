//## Copyright (c) 2017-2019 The Khronos Group Inc.
//## Copyright (c) 2019 Collabora, Ltd.
//##
//## Licensed under the Apache License, Version 2.0 (the "License");
//## you may not use this file except in compliance with the License.
//## You may obtain a copy of the License at
//##
//##     http://www.apache.org/licenses/LICENSE-2.0
//##
//## Unless required by applicable law or agreed to in writing, software
//## distributed under the License is distributed on an "AS IS" BASIS,
//## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//## See the License for the specific language governing permissions and
//## limitations under the License.
//##
//## ---- Exceptions to the Apache 2.0 License: ----
//##
//## As an exception, if you use this Software to generate code and portions of
//## this Software are embedded into the generated code as a result, you may
//## redistribute such product without providing attribution as would otherwise
//## be required by Sections 4(a), 4(b) and 4(d) of the License.
//##
//## In addition, if you combine or link code generated by this Software with
//## software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
//## ("`Combined Software`") and if a court of competent jurisdiction determines
//## that the patent provision (Section 3), the indemnity provision (Section 9)
//## or other Section of the License conflicts with the conditions of the
//## applicable GPL or LGPL license, you may retroactively and prospectively
//## choose to deem waived or otherwise exclude such Section(s) of the License,
//## but only in their entirety and only with respect to the Combined Software.



// BLOCK Structure Impl definitions
namespace OPENXR_HPP_NAMESPACE {

//# for struct in gen.api_structures
//#     set projected_type = project_type_name(struct.name)
/*{ protect_begin(struct) }*/
struct /*{ projected_type}*/ {
//# if not struct.returned_only and not struct.name.startswith("XrBase") and not struct.name.endswith("BaseHeader") and not struct.name == 'XrEventDataBuffer'
#ifndef OPENXR_HPP_NO_CONSTRUCTOR
/*{projected_type }*/ (
//# for member in struct.members if not cpp_hidden_member(member)
//# set projected_member_type = project_type_name(member.type)
//# set param_decl = project_cppdecl(struct, member, defaulted=True, suffix="_", input=True)
/*{param_decl}*/ /*{- "," if not loop.last }*/
//# endfor
    )
//# for member in struct.members if not cpp_hidden_member(member) and not is_static_length_string(member)
    /*{ " : " if loop.first }*/ /*{ member.name }*/ {/*{ member.name + "_"}*/} /*{ "," if not loop.last }*/
//# endfor
{
    //# for member in struct.members if not cpp_hidden_member(member) and is_static_length_string(member)
    if (nullptr != /*{ member.name + "_" }*/) {
        // FIXME what is the safe way to do this?
        strncpy(/*{ member.name }*/, /*{ member.name + "_" }*/, /*{member.array_count_var}*/);
    }
    //# endfor
}
#endif
//# endif

operator const /*{ struct.name }*/&() const { return *reinterpret_cast<const /*{ struct.name }*/*>(this); }
/*{ "operator " + struct.name }*/ &() {
    return *reinterpret_cast</*{ struct.name }*/*>(this);
}

//# for member in struct.members if member.name not in parent_fields
//# if struct.returned_only or (struct.name == 'XrEventDataBuffer' and not cpp_hidden_member(member))
/*{ project_cppdecl(struct, member, defaulted=False) }*/;
//# else
/*{ project_cppdecl(struct, member, defaulted=True) }*/;
//# endif
//# endfor
};
static_assert(sizeof(/*{projected_type }*/) == sizeof(/*{struct.name}*/), "struct and wrapper have different size!");

//! @brief Free function accessor for /*{projected_type}*/ const reference as a raw /*{struct.name}*/ const pointer
//! @relates /*{projected_type}*/
OPENXR_HPP_INLINE /*{struct.name}*/ const* get(/*{projected_type}*/ const& h) {
    return &(h./*{"operator " + struct.name}*/ const&());
}

//! @brief Free function accessor for passing /*{projected_type}*/ as the address of a raw /*{struct.name}*/
//! @relates /*{projected_type}*/
OPENXR_HPP_INLINE /*{struct.name}*/* put(/*{projected_type}*/ &h) { return &(h./*{"operator " + struct.name}*/&()); }

/*{ protect_end(struct) }*/
//# endfor

}  // namespace OPENXR_HPP_NAMESPACE
